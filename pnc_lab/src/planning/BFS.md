# BFS (广度优先搜索) 路径规划算法详解

## 1. 算法核心概念：水波纹扩散

**广度优先搜索 (BFS)** 是一种用于在图或网格中寻找路径的基础算法。它通过在离散的网格地图上**层层递进**地探索，来保证找到从起点到终点的**最短路径（步数最少）**。

> **心法类比**：BFS 的搜索过程就像是往平静的湖面扔了一颗石子（起点）。水波（搜索范围）会一圈一圈均匀地向外扩散，直到触碰到目标点。

## 2. 算法流程与关键组件

### A. 准备工作：离散化与容器初始化

在开始搜索前，需要将连续的世界坐标（$x, y$）映射到离散的网格索引（$gx, gy$），这是在计算机中进行图搜索的前提。

需要初始化三个核心数据结构来支持搜索和路径还原：

| 数据结构 | 名称 | 作用 | 对应代码 |
| :--- | :--- | :--- | :--- |
| **队列 (List)** | `q` | 遵循 **FIFO（先进先出）** 原则，用于存放待访问的节点，保证搜索是逐层进行的。 | `q.append()`, `q.pop(0)` |
| **集合 (Set)** | `visited` | 记录已经访问过的格子，防止走回头路或陷入死循环。 | `visited.add()` |
| **字典 (Dict)** | `parent` | 记录节点的“族谱”。`parent[子节点] = 父节点`，是最后还原路径的关键。 | `parent[(nx,ny)] = curr` |

### B. 碰撞检测与安全膨胀

为了让机器人安全通行，算法在判断格子是否可走时，会执行碰撞检测。

* **安全膨胀（Inflation）**：通过加入一个安全距离参数（如代码中的 `SAFE_DIS`），在判断时会将障碍物的体积扩大，保证机器人不会贴着障碍物行走。
* **网格中心判断**：判断当前格子的中心点是否落入任何障碍物的膨胀区域内。

### C. 主循环：逐层扩散与拓展

BFS 的核心在于 `while q:` 循环。

1.  **取出当前点**：从队列头部 `q.pop(0)` 取出当前正在处理的节点 `curr`。
2.  **判断终止条件**：如果 `curr` 就是终点 `goal`，则搜索成功，立即停止。
3.  **邻居拓展**：遍历 `curr` 周围的所有邻居（本实现使用**八连通**，即允许横、竖、斜向移动）。
4.  **三条件检查**：对于每一个邻居 $(nx, ny)$，必须同时满足以下三个条件才允许入队：
    * 没有超出地图边界。
    * 没有被 `visited` 记录过。
    * 不是障碍物（通过碰撞检测）。
5.  **入队操作**：若满足条件，将其加入 `visited`，在 `parent` 中记录其父节点为 `curr`，并将它放入队列尾部 `q.append()`，等待下一轮处理。

### D. 路径回溯与生成

当搜索成功终止后，我们通过 `parent` 字典来构造最终路径：

1.  从终点开始，不断查询其父节点，直到回溯到起点。
2.  将回溯得到的路径序列**反转**，得到从起点到终点的完整、最优（步数最少）的路径。

---

## 3. 3x3 示例推演流程

假设我们在一个 3x3 的地图上，起点 **S(0,0)**，终点 **G(2,2)**，中间障碍物 **X(1,1)**。

| 步骤 | 队列状态 `q` | 扩散节点 `curr` | 新发现节点 | 记录的父节点 `parent` (新增) |
| :--- | :--- | :--- | :--- | :--- |
| **T=0** | `[(0,0)]` | (初始化) | - | - |
| **T=1** | `[(1,0), (0,1)]` | **(0,0)** | (1,0), (0,1) | `(1,0):(0,0)`, `(0,1):(0,0)` |
| **T=2** | `[(0,1), (2,0), (2,1)]` | **(1,0)** | (2,0), (2,1) | `(2,0):(1,0)`, `(2,1):(1,0)` |
| **T=3** | `[(2,0), (2,1), (0,2), (1,2)]` | **(0,1)** | (0,2), (1,2) | `(0,2):(0,1)`, `(1,2):(0,1)` |
| **...** | (持续处理) | **(2,1)** | **(2,2)** (Goal!) | `(2,2):(2,1)` |
| **T=End** | (弹出 **(2,2)**) | **(2,2)** | - | **搜索终止** |

**最终最短路径回溯链：**
$$\text{G}(2,2) \xleftarrow{\text{parent}} (2,1) \xleftarrow{\text{parent}} (1,0) \xleftarrow{\text{parent}} \text{S}(0,0)$$

**输出路径：** $(0,0) \to (1,0) \to (2,1) \to (2,2)$

---

## 4. BFS 算法的优缺点

| 特性 | 优点 | 缺点 |
| :--- | :--- | :--- |
| **完备性** | 只要起点和终点之间有路径，BFS 一定能找到。 | - |
| **最优性** | 在无权网格中，保证找到步数最少的路径。 | - |
| **搜索效率** | - | 属于“盲目搜索”，会向四周均匀扩散，在大型或稀疏地图中效率低于 A* 等启发式算法。 |
| **内存消耗** | - | 需要存储所有访问过的节点 (`visited` 和 `parent` 字典)，在大型网格中内存消耗较大。 |