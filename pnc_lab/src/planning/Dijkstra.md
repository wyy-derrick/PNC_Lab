

# Dijkstra (迪杰斯特拉) 路径规划算法详解

## 1\. 算法核心概念：代价优先

如果说 BFS 是“只看步数”的盲目扩散，那么 **Dijkstra 算法** 就是“精打细算”的探索家。

在真实物理世界中，走直线（网格的上下左右）和走斜线（对角线）的距离是不一样的。BFS 认为走斜线和走直线都算“1步”，这会导致生成的路径虽然步数少，但实际物理距离可能不是最短的。

**Dijkstra 的核心思想**：
算法维护一个\*\*“累积代价”**。每次做决定时，永远优先处理当前**累积代价最小\*\*的那个节点。它保证了：**当算法第一次“选中”终点时，这条路径的物理总距离绝对是最短的。**

## 2\. 算法流程与关键组件

与 BFS 相比，Dijkstra 引入了“权重”的概念，因此其核心组件发生了变化：

| 数据结构 | 名称 | 作用 | 与 BFS 的区别 |
| :--- | :--- | :--- | :--- |
| **优先队列** | `pq` | 存放待访问节点。**最关键的区别**：它不是先进先出，而是**谁的代价小，谁先出队**。 | BFS 用普通列表，Dijkstra 用最小堆 (Heap)。 |
| **字典 (哈希表)** | `dist` | 记录从起点到某点的**已知最短距离**。 | BFS 不需要记录具体距离数值。 |
| **字典** | `parent` | 记录“族谱”，用于回溯路径。 | 与 BFS 一致。 |
| **移动权重** | `w` | 定义移动的消耗。 | 直线代价 = 1.0<br>斜线代价 $\approx$ 1.414 |

### 核心逻辑：松弛 (Relaxation)

Dijkstra 的搜索过程包含一个不断“刷新三观”的过程，术语叫**松弛**：

> "我原本以为走到格子 A 需要代价 10。现在我发现通过格子 B 走到 A 只需要代价 8。于是我更新记录：去 A 的最短代价是 8，且 A 的父亲是 B。"

## 3\. 3x3 示例推演流程

为了展示 Dijkstra 如何处理“斜向距离”，我们再次使用 **3x3** 地图。

  * **起点 (S)**: `(0, 0)`
  * **终点 (G)**: `(2, 1)` (注意终点位置变化，以便展示代价差异)
  * **障碍**: 无
  * **规则**：直线移动代价 **1.0**，斜线移动代价 $\sqrt{2} \approx$ **1.4**。

**目标**：找到去往 `(2, 1)` 的最短路径。

| 步骤 | 优先队列状态 `pq` [(代价, 坐标)...] | 当前弹出 `u` | 行为分析 |
| :--- | :--- | :--- | :--- |
| **T=0** | `[(0, (0,0))]` | - | 初始化，起点代价为 0。 |
| **T=1** | `[(1.0, (1,0)),`<br>`  (1.0, (0,1)), `<br>`  (1.4, (1,1))] ` | **(0,0)** | 扩展起点周围。发现三个邻居：<br>1. (1,0) 直走，代价 1.0<br>2. (0,1) 直走，代价 1.0<br>3. (1,1) 斜走，代价 1.4 |
| **T=2** | `[(1.0, (0,1)),`<br>`  (1.4, (1,1)), `<br>`  (2.0, (2,0)), `<br>`  (2.4, (2,1))] ` | **(1,0)** | 弹出代价最小的 `(1,0)`。<br>扩展其邻居：<br>1. (2,0) 直走，总代价 1.0+1.0=2.0<br>2. **(2,1)** 斜走，总代价 1.0+1.4=2.4 (发现终点！但代价较高，先入队，不结算) |
| **T=3** | `[(1.4, (1,1)),`<br>`  (2.0, (2,0)), `<br>`  (2.4, (2,1))...] ` | **(0,1)** | 弹出当前最小的 `(0,1)` (代价 1.0)。<br>扩展略... (产生的新节点代价都大于 1.4) |
| **T=4** | `[(2.0, (2,0)),`<br>`  (2.4, (2,1)), `<br>`  (2.4, (2,1))...] ` | **(1,1)** | **关键时刻！**<br>虽然 (2,0) 是 (1,0) 的直系邻居，但 **(1,1) 的累积代价 (1.4) 比 (2,0) 的 (2.0) 小**，所以先处理 (1,1)。<br>扩展 (1,1) 的邻居：<br>1. **(2,1) 直走**，总代价 1.4+1.0 = **2.4**。 |
| **...** | ... | ... | ... |
| **T=End** | 弹出 **(2,1)** | **(2,1)** | 队列中代价最小的是终点 `(2,1)`。搜索结束。 |

> **注意**：在这个例子中，虽然通过 `(1,0)` 斜着走到 `(2,1)` 和通过 `(1,1)` 直着走到 `(2,1)` 总代价都是 2.4，但在更复杂的地图中，Dijkstra 会严格按照“谁便宜谁先走”的顺序，绕过高代价区域（如泥泞路段），找到真正的最短路径。

## 4\. 路径回溯

回溯逻辑与 BFS 完全一致：

1.  从终点 `(2, 1)` 开始查 `parent` 字典。
2.  假设最后路径是通过 `(1, 1)` 来的： `(2,1) -> (1,1) -> (0,0)`。
3.  反转列表，输出最终物理坐标路径。

## 5\. Dijkstra 与 BFS 的对比总结

| 维度 | BFS (广度优先) | Dijkstra (迪杰斯特拉) |
| :--- | :--- | :--- |
| **核心容器** | **Queue (普通队列)**<br>先进先出 | **Priority Queue (优先队列)**<br>代价小的先出 |
| **看待地图** | **无权图**<br>所有格子地位平等，只在乎“几步”能到。 | **带权图**<br>承认“斜着走”比“直着走”远，也承认不同地形通行难度不同。 |
| **路径质量** | **步数最少**<br>但物理距离未必最短（因为斜线也被当成一步）。 | **物理距离最短**<br>精准计算实际移动距离。 |
| **效率** | 较高（逻辑简单）。 | 稍低（因为涉及优先队列的排序操作）。 |
| **适用场景** | 简单的迷宫、无权网格、填充算法。 | 真实的机器人导航、地图导航（考虑路程长短）。 |

-----

### 教学小结

这段代码通过引入 `heapq` (最小堆) 和数学计算 (`math.sqrt(2)`), 将路径规划从简单的“数格子”升级为了“算距离”。它是现代自动驾驶和机器人导航中最基础、最重要的算法思想之一。