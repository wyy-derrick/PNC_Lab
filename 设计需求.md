这是一份为您定制的详细技术需求文档。这份文档采用了专业的软件工程需求说明书（SRS）格式，专门针对您的PNC（Planning and Control）算法实验室设计。

您可以直接将以下Markdown内容复制并保存为 `仓库设计需求.md`，发送给开发人员（或作为您自己的开发蓝图）。

-----

# 仓库设计需求文档：自动驾驶PNC算法仿真验证平台

## 1\. 项目概述 (Project Overview)

本项目旨在构建一个模块化、轻量级且易于扩展的Python代码仓库，用于自动驾驶规划（Planning）与控制（Control）算法的学习、验证与可视化。

**核心目标：**

  * **解耦性：** 仿真环境、规划器、控制器必须严格解耦，通过标准接口通信。
  * **可视化：** 基于 `matplotlib` 实现低延迟的实时仿真动画，便于观察车辆状态与路径追踪效果。
  * **扩展性：** 能够通过简单的类继承快速添加新的算法（如由纯跟踪扩展到MPC）。

-----

## 2\. 系统架构与文件结构 (System Architecture)

系统采用典型的 **输入-处理-输出** 闭环架构。建议采用面向对象编程（OOP）与工厂模式设计。

### 2.1 推荐目录结构

```text
pnc_lab/
├── config/                 # 配置文件
│   └── default_config.yaml # 存储车辆参数、PID增益、地图尺寸等
├── src/
│   ├── env/                # 仿真环境模块
│   │   ├── __init__.py
│   │   ├── vehicle.py      # 车辆运动学模型
│   │   ├── map.py          # 地图与障碍物生成
│   │   └── visualizer.py   # Matplotlib绘图接口
│   ├── planning/           # 轨迹规划模块
│   │   ├── __init__.py
│   │   ├── planner_base.py # 规划器基类（接口定义）
│   │   ├── a_star.py       # A* 实现
│   │   └── bfs.py          # BFS 实现
│   ├── control/            # 控制模块
│   │   ├── __init__.py
│   │   ├── controller_base.py # 控制器基类（接口定义）
│   │   ├── pure_pursuit.py    # 纯跟踪算法
│   │   ├── stanley.py         # Stanley算法
│   │   ├── lqr.py             # LQR算法
│   │   └── mpc.py             # MPC算法
│   └── utils/              # 通用工具
│       ├── math_utils.py   # 角度归一化、距离计算等
│       └── types.py        # 定义State, Point等数据结构
├── main.py                 # 主程序入口
├── requirements.txt        # 依赖库
└── README.md
```

-----

## 3\. 详细模块需求 (Module Requirements)

### 3.1 仿真环境模块 (Simulation Environment)

该模块负责维护物理世界的“真实”状态。

#### 3.1.1 车辆模型 (`vehicle.py`)

  * **模型依据：** 自行车运动学模型 (Kinematic Bicycle Model)。
  * **状态空间：** 必须维护车辆状态向量 $S = [x, y, v, \theta]$ (位置x, 位置y, 线速度, 航向角)。
  * **输入控制量：** $u = [a, \delta]$ (加速度, 前轮转角)。
  * **核心方法：** `update(action, dt)`。根据离散时间微分方程更新车辆状态。
      * $$x_{t+1} = x_t + v_t \cos(\theta_t) \cdot dt$$
      * $$y_{t+1} = y_t + v_t \sin(\theta_t) \cdot dt$$
      * $$\theta_{t+1} = \theta_t + \frac{v_t}{L} \tan(\delta_t) \cdot dt$$ (其中 $L$ 为轴距)
      * $$v_{t+1} = v_t + a_t \cdot dt$$

#### 3.1.2 地图与障碍物 (`map.py`)

  * **地图边界：** 固定大小（例如 $50m \times 50m$），需在Config中可配。
  * **起终点：**
      * `Start`: 固定坐标（如 `(5, 5)`）。
      * `Goal`: 固定坐标（如 `(45, 45)`）。
  * **障碍物生成逻辑：**
      * **类型：** 静态障碍物（圆形或矩形）。
      * **随机性：** 初始化时生成 $N$ 个障碍物（$N$ 为随机范围整数）。
      * **尺寸：** 障碍物半径/边长在一定范围内随机（如 $1m - 3m$）。
      * **约束：** 障碍物生成时不得覆盖起点和终点，且不能完全封死所有通路（可选：生成后进行一次连通性检查，若不连通则重置）。

#### 3.1.3 可视化 (`visualizer.py`)

  * **工具：** `matplotlib.pyplot`。
  * **模式：** 必须使用 `plt.ion()` (交互模式) 实现动态刷新，而非每次关闭弹窗。
  * **图层管理：**
    1.  **静态层：** 地图边界、障碍物、起点终点（只绘制一次）。
    2.  **规划层：** 全局路径（规划完成后绘制一次，或重规划时更新）。
    3.  **动态层：** 车辆当前位置（小车图标或矩形+箭头）、历史轨迹残影、当前参考点（Lookahead Point）。
    4.  **数据面板：** 在图表角落实时显示当前速度 $v$、横向误差 $e_{lat}$、航向误差 $e_{psi}$。

-----

### 3.2 全局轨迹规划模块 (Global Planning)

该模块负责生成从起点到终点的无碰撞路径。

#### 3.2.1 接口定义 (`planner_base.py`)

所有规划算法必须继承自基类，并实现以下接口：

```python
def plan(self, start_pos, goal_pos, obstacle_list) -> List[Point]:
    pass
```

#### 3.2.2 算法实现要求

  * **输入：** 离散化的栅格地图（Grid Map）或 采样点。
  * **输出：** 一系列密集的路径点 `[(x1, y1), (x2, y2), ...]`。
  * **具体算法：**
      * **BFS (广度优先搜索):** 简单的基于栅格的波前扩展。
      * \**A* (A-Star):\*\* 引入启发式函数 $h(n)$ (欧几里得距离或曼哈顿距离) 的搜索。
  * **后处理（可选但推荐）：** 路径平滑（如使用B样条或简单的平均值滤波），因为栅格搜索出来的路径通常是锯齿状的，不利于车辆追踪。

-----

### 3.3 控制模块 (Control)

该模块负责计算车辆的具体执行指令，使车辆尽可能贴合全局路径。

#### 3.3.1 接口定义 (`controller_base.py`)

所有控制器必须继承自基类：

```python
def compute_command(self, current_state, global_path) -> ControlCommand:
    """
    Returns:
        acceleration (float): 目标加速度/油门
        steering_angle (float): 目标前轮转角
    """
    pass
```

#### 3.3.2 算法实现细节

  * **纵向控制：** 简单的PID控制器，将车辆速度维持在设定值（Target Speed）。
  * **横向控制（核心）：**
      * **Pure Pursuit (纯跟踪):** 基于预瞄距离 $L_d$ 寻找路径上的目标点，计算转角。要求 $L_d$ 随速度动态调整 ($L_d = k \cdot v + L_{min}$)。
      * **Stanley Controller:** 基于前轴中心的横向误差 $e_{fa}$ 和航向误差 $\theta_e$ 的非线性反馈控制。
      * **LQR/MPC:** 基于状态方程的最优控制（作为进阶模块）。
  * **可视化调试：** 控制器计算出的“目标追踪点”或“预测轨迹”应暴露给 `Visualizer` 进行绘制，以便直观调试参数。

-----

## 4\. 主程序流程 (Main Loop Logic)

`main.py` 负责组装各模块。伪代码逻辑如下：

```python
# 初始化
config = load_config("config.yaml")
env = Environment(config)
planner = AStarPlanner(config)
controller = PurePursuitController(config)

# 1. 生成环境
obstacles = env.generate_random_obstacles()

# 2. 全局规划
global_path = planner.plan(env.start, env.goal, obstacles)
env.visualizer.plot_static(obstacles, global_path)

# 3. 仿真循环
time = 0
while not env.is_reached_goal() and time < MAX_TIME:
    # 获取当前状态
    state = env.get_vehicle_state()
    
    # 计算控制量
    cmd = controller.compute_command(state, global_path)
    
    # 更新物理环境
    env.step(cmd)
    
    # 实时渲染
    env.render()
    
    time += dt
```

-----

## 5\. 配置与参数化需求 (Configuration)

为了方便调整参数（Tuning），所有关键参数**严禁硬编码**在代码中，必须从 YAML/JSON 文件读取。

**需参数化的内容包括：**

  * **车辆物理参数：** 轴距 $L$、最大转角 $\delta_{max}$、最大加速度 $a_{max}$。
  * **仿真参数：** 时间步长 $dt$、地图尺寸。
  * **规划参数：** A\*的栅格分辨率、安全距离余量。
  * **控制参数：**
      * 纯跟踪：预瞄系数 $k$。
      * Stanley：增益 $k$。
      * PID：$K_p, K_i, K_d$。

-----

## 6\. 开发交付标准 (Deliverables)

1.  **代码规范：** 符合 PEP8 规范，关键函数必须有 Docstring 说明输入输出格式。
2.  **依赖管理：** 提供 `requirements.txt`。
3.  **Demo演示：** 提供一个 `demo_run.gif` 或视频，展示小车成功绕过随机障碍物到达终点的过程。

-----

### 下一步建议

**您可以这样向开发者描述任务：**

> "我需要一个用于验证自动驾驶算法的Python框架。请按照这份《仓库设计需求文档》进行开发。第一阶段请先完成：带有随机障碍物的自行车模型仿真环境，A\*规划器，以及一个基础的纯跟踪（Pure Pursuit）控制器。必须保证我在配置文件里修改轴距或PID参数后，不用改代码就能直接运行生效。"

**我能为您做的下一步：**
如果您准备开始自己写代码，我可以为您生成 **核心的文件目录结构和 `vehicle.py` (车辆运动学模型) 的基础代码**，帮您把脚手架搭起来。您需要吗？